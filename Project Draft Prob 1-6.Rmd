---
title: "276 Project"
author: "Ron Kinel, Rebecca He, Lingyu Zhou, Wenjing Li, Samran Khan"
date: "5/22/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Problem 1

```{r p1}
StockVol <- function(histoPrice){

  R <- array(0 , length(histoPrice)-1)
  for (i in 1:(length(R))){
    R[i] <- log(histoPrice[i+1]/histoPrice[i])
  }
  Daily_vol <- sqrt(var(R))
  Annual_Vol <- Daily_vol*sqrt(252)
  return(Annual_Vol)
}


```


# Problem 2

```{r p2}
#n: number of paths
#sigma: volatilty/variance of stock, not sd
#S0: current stock price
#t: terminal time in yearly unit
#np: number of periods
#r: interest rate
#delta: continuous dividend yield of the stock

StockPath <- function(n, sigma, S0, t, np=t, r, delta=0){
  S <- array(0, dim=c(n,np+1))
  S[,1] <- S0
  Z <- matrix( rnorm(n*(np)), n, (np))
  h <- t/np 
  #h: length of each period = t/np
  
  for(i in 1:n){
    for (j in 1:np){
      S[i,j+1] <- S[i,j]*exp((r-delta-(sigma^2)/2)*h + sqrt(h*(sigma^2))*Z[i,j])
    }
  }
  
  mypath <- S
  return(mypath)
}

```


# Problem 3

```{r p3}
set.seed(20)

EurOptPrice <- function(n, sigma, S0, t, np=t, r, delta=0, k=S0){
  mypath <- StockPath(n, sigma, S0, t, np, r, delta) #updates "mypath" from problem 2 with new values.
  
  disc_payoff <- array(0, dim=c(n,1)) #discounted payoff vector
  
  for (i in 1:n){
    disc_payoff[i,1] <- exp(-r*t)*pmax(k-mypath[i,(np+1)] ,0)
  }
  
  option_price <- mean(disc_payoff)
  option_var <- var(disc_payoff)
  
   return(list( disc_payoff , option_price, option_var))
}

```

#Problem 4

```{r}
AmeOptPrice <- function(C, t, r, k = C[1,1]){
  #t is time in years until maturity -- needs to match t in stock path function?
  degree0 <- function (x) rep(1,length(x)) 
  degree1 <- function (x) x
  degree2 <- function (x) x^2
  model <- list(degree0,degree1,degree2) 
  S0 <- C[1,1]
  Paths <- nrow(C)
  Steps <- ncol(C)-1
  dt <- t/Steps #time interval for each step
  df <- exp(-r*dt*(1:Steps)) #all discounting factors
  num_model <-length(model) #number of functions used in model
  C <- C[,-1] #first column is simply S0, so remove it 
  Value_t <- pmax(k - C[,Steps], 0) #value at time t
  exercise_time <- Steps*rep(1,Paths)
  discounted_payoff <- c(rep(0,20))
  for (i in seq(from=Steps-1, to=1, by=-1)){ #make comparisons starting from the last two column
    Payoff_Value <- pmax(k - C[,i], 0)
    gain <- which(Payoff_Value > 0) #find rows with positive gains
   # discounted_payoff[-gain,i] <- 0
    paths_gain <- C[gain,i] #generate a matrix with current row and column
    regress_Matrix <- matrix(nrow=length(paths_gain), ncol= num_model)
    for (j in 1:num_model) {
      regress_Matrix[,j] <- sapply(paths_gain,model[[j]]) #apply regression on current matrix
    }
    temp <- Value_t[gain]*df[exercise_time[gain]-i]
    discounted_payoff[gain] <- temp
    regress_model <- lm.fit(regress_Matrix,temp)
    Vector <- as.numeric(regress_model$coefficients)   
    Holding_Value <- regress_Matrix%*%Vector
    perform_time <- which(Payoff_Value[gain]>Holding_Value)
    exercise_Paths <- gain[perform_time]
    Value_t[exercise_Paths] <- Payoff_Value[exercise_Paths]
    exercise_time[exercise_Paths] <- i #in i-th col, we exercise
  }
  price <- pmax(pmax(k-S0, 0),mean(Value_t*df[exercise_time]))
  variance <- var(discounted_payoff)
  return(list(price,discounted_payoff,variance))
}

```

```{r}
Prices <- read.csv(file = '/Users/lingyuzhou/Desktop/IBM-MSFT-HAS.csv', header = T, sep = ",")
IBM_Vol <- StockVol(Prices$IBM)
MSFT_Vol <- StockVol(Prices$MSFT)
HAS_Vol <- StockVol(Prices$HAS)
IBM_Path <- StockPath(20, sigma <- IBM_Vol ,S0 =
                        Prices$IBM[length(Prices$IBM)] , 3 ,6,.06,0)
MSFT_Path <- StockPath(20, sigma <- MSFT_Vol ,S0 = 
                         Prices$MSFT[length(Prices$MSFT)] , 3 ,6,.06,0)
HAS_Path <- StockPath(20, sigma <- HAS_Vol ,S0 =
                        Prices$HAS[length(Prices$HAS)] , 3 ,6,.06,0)

Prices_IBM <- as.matrix(IBM_Path)
Prices_MSFT <- as.matrix(MSFT_Path)
Prices_HAS <- as.matrix(HAS_Path)
r <- 0.06
T <- 3
IBM_put <- AmeOptPrice(Prices_IBM,T,r)
MSFT_put <- AmeOptPrice(Prices_MSFT,T,r)
HAS_put <- AmeOptPrice(Prices_HAS,T,r)
IBM_put
#MSFT_put
#HAS_put
```


#Problem 5

```{r p5}

ContVariate <- function(Unknown_Vec, Known_Vec, Known_Value){
  B <- cov(Unknown_Vec, Known_Vec)/var(Known_Vec)
  Ca <- Unknown_Vec + B*(Known_Vec - Known_Value)
  return(mean(Ca))
}

```

#Problem 6
#Choose your favorite underlying stock and a corresponding put option that expires in 1 year. Use 1 year libor yield as the interest rate. You also need to compute the continuous dividend yield. Apply the ContVariate function to the American put option price you computed. Do the analysis as if you want to convince your manager that this is the right way to estimate the price of American style option.

```{r p6}

New_IBM_Path <- StockPath(20, sigma <- IBM_Vol ,S0 = Prices$IBM[length(Prices$IBM)] , 1 ,12,.0062,0)
r <- 0.0062
T <- 1

ST <- New_IBM_Path[,ncol(New_IBM_Path)]
Expected_ST <- New_IBM_Path[,1]*exp(r*T)
New_Prices_IBM <- as.matrix(IBM_Path)
New_IBM_put <- AmeOptPrice(Prices_IBM,T,r)
Discounted_Payoff <- New_IBM_put[2][[1]]
Option_Price <- New_IBM_put[1]
Controlled_Value <- ContVariate(Discounted_Payoff, ST, Expected_ST)
Option_Price[[1]]
Controlled_Value
```







